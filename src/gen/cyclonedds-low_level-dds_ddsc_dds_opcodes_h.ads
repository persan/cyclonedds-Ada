pragma Ada_2012;
pragma Style_Checks (Off);
pragma Warnings ("U");

with Interfaces.C; use Interfaces.C;

package CycloneDDS.Low_Level.dds_ddsc_dds_opcodes_h is

   --  unsupported macro: DDS_OP_TYPE_BOO DDS_OP_TYPE_1BY
   --  unsupported macro: DDS_OP_SUBTYPE_BOO DDS_OP_SUBTYPE_1BY
   DDS_OP_FLAG_KEY : constant :=
     16#01#;  --  /usr/gnat/include/dds/ddsc/dds_opcodes.h:131
   DDS_OP_FLAG_DEF : constant :=
     16#02#;  --  /usr/gnat/include/dds/ddsc/dds_opcodes.h:132

   DDS_OP_FLAG_FP : constant :=
     16#02#;  --  /usr/gnat/include/dds/ddsc/dds_opcodes.h:138
   DDS_OP_FLAG_SGN : constant :=
     16#04#;  --  /usr/gnat/include/dds/ddsc/dds_opcodes.h:139

   DDS_TOPIC_NO_OPTIMIZE : constant :=
     16#0001#;  --  /usr/gnat/include/dds/ddsc/dds_opcodes.h:143
   DDS_TOPIC_FIXED_KEY : constant :=
     16#0002#;  --  /usr/gnat/include/dds/ddsc/dds_opcodes.h:144
   DDS_TOPIC_CONTAINS_UNION : constant :=
     16#0004#;  --  /usr/gnat/include/dds/ddsc/dds_opcodes.h:145
   DDS_TOPIC_DISABLE_TYPECHECK : constant :=
     16#0008#;  --  /usr/gnat/include/dds/ddsc/dds_opcodes.h:146
   DDS_TOPIC_FIXED_SIZE : constant :=
     16#0010#;  --  /usr/gnat/include/dds/ddsc/dds_opcodes.h:147

-- * Copyright(c) 2021 ADLINK Technology Limited and others
-- *
-- * This program and the accompanying materials are made available under the
-- * terms of the Eclipse Public License v. 2.0 which is available at
-- * http://www.eclipse.org/legal/epl-2.0, or the Eclipse Distribution License
-- * v. 1.0 which is available at
-- * http://www.eclipse.org/org/documents/edl-v10.php.
-- *
-- * SPDX-License-Identifier: EPL-2.0 OR BSD-3-Clause
   --

   --* @file
   -- *
-- * @brief DDS C (de)serialization opcodes
-- *
-- * Opcodes for (de)serialization of types generated by idlc. Isolated in a
-- * separate header to share with idlc without the need to pull in the entire
-- * Eclipse Cyclone DDS C language binding.
   --

   -- Topic encoding instruction types
   subtype dds_stream_opcode is unsigned;
   DDS_OP_RTS : constant dds_stream_opcode := 0;
   DDS_OP_ADR : constant dds_stream_opcode := 16_777_216;
   DDS_OP_JSR : constant dds_stream_opcode := 33_554_432;
   DDS_OP_JEQ : constant dds_stream_opcode := 50_331_648;

   -- return from subroutine, exits top-level
   --     [RTS,   0,   0, 0]

   -- data field
   --     [ADR, nBY,   0, k] [offset]
   --     [ADR, STR,   0, k] [offset]
   --     [ADR, BST,   0, k] [offset] [bound]
   --     [ADR, SEQ, nBY, 0] [offset]
   --     [ADR, SEQ, STR, 0] [offset]
   --     [ADR, SEQ, BST, 0] [offset] [bound]
   --     [ADR, SEQ,   s, 0] [offset] [elem-size] [next-insn, elem-insn]
   --       where s = {SEQ,ARR,UNI,STU}
   --     [ADR, ARR, nBY, k] [offset] [alen]
   --     [ADR, ARR, STR, 0] [offset] [alen]
   --     [ADR, ARR, BST, 0] [offset] [alen] [0] [bound]
   --     [ADR, ARR,   s, 0] [offset] [alen] [next-insn, elem-insn] [elem-size]
   --         where s = {SEQ,ARR,UNI,STU}
   --     [ADR, UNI,   d, z] [offset] [alen] [next-insn, cases]
   --       where
   --         d = discriminant type of {1BY,2BY,4BY}
   --         z = default present/not present (DDS_OP_FLAG_DEF)
   --         offset = discriminant offset
   --       followed by alen case labels: in JEQ format
   --     note: [ADR, STU, ...] is illegal
   --   where
   --     s            = subtype
   --     k            = key/not key (DDS_OP_FLAG_KEY)
   --     [offset]     = field offset from start of element in memory
   --     [elem-size]  = element size in memory
   --     [bound]      = string bound + 1
   --     [alen]       = array length, number of cases
   --     [next-insn]  = (unsigned 16 bits) offset to instruction for next field, from start of insn
   --     [elem-insn]  = (unsigned 16 bits) offset to first instruction for element, from start of insn
   --     [cases]      = (unsigned 16 bits) offset to first case label, from start of insn
   --

   -- jump-to-subroutine (apparently not used at the moment)
   --     [JSR,   0, e]
   --       where
   --         e = (signed 16 bits) offset to first instruction in subroutine, from start of insn
   --             instruction sequence must end in RTS, execution resumes at instruction
   --             following JSR

   -- union case
   --     [JEQ, nBY, 0] [disc] [offset]
   --     [JEQ, STR, 0] [disc] [offset]
   --     [JEQ,   s, e] [disc] [offset]
   --       where
   --         s  = subtype other than {nBY,STR}
   --         e  = (unsigned 16 bits) offset to first instruction for case, from start of insn
   --              instruction sequence must end in RTS, at which point executes continues
   --              at the next field's instruction as specified by the union

   subtype dds_stream_typecode is unsigned;
   DDS_OP_VAL_1BY : constant dds_stream_typecode := 1;
   DDS_OP_VAL_2BY : constant dds_stream_typecode := 2;
   DDS_OP_VAL_4BY : constant dds_stream_typecode := 3;
   DDS_OP_VAL_8BY : constant dds_stream_typecode := 4;
   DDS_OP_VAL_STR : constant dds_stream_typecode := 5;
   DDS_OP_VAL_BST : constant dds_stream_typecode := 6;
   DDS_OP_VAL_SEQ : constant dds_stream_typecode := 7;
   DDS_OP_VAL_ARR : constant dds_stream_typecode := 8;
   DDS_OP_VAL_UNI : constant dds_stream_typecode := 9;
   DDS_OP_VAL_STU : constant dds_stream_typecode := 10;

   -- one byte simple type (char, octet, boolean)
   -- two byte simple type ((unsigned) short)
   -- four byte simple type ((unsigned) long, enums, float)
   -- eight byte simple type ((unsigned) long long, double)
   -- string
   -- bounded string
   -- sequence
   -- array
   -- union
   -- struct
   -- primary type code for DDS_OP_ADR, DDS_OP_JEQ
   subtype dds_stream_typecode_primary is unsigned;
   DDS_OP_TYPE_1BY : constant dds_stream_typecode_primary := 65_536;
   DDS_OP_TYPE_2BY : constant dds_stream_typecode_primary := 131_072;
   DDS_OP_TYPE_4BY : constant dds_stream_typecode_primary := 196_608;
   DDS_OP_TYPE_8BY : constant dds_stream_typecode_primary := 262_144;
   DDS_OP_TYPE_STR : constant dds_stream_typecode_primary := 327_680;
   DDS_OP_TYPE_BST : constant dds_stream_typecode_primary := 393_216;
   DDS_OP_TYPE_SEQ : constant dds_stream_typecode_primary := 458_752;
   DDS_OP_TYPE_ARR : constant dds_stream_typecode_primary := 524_288;
   DDS_OP_TYPE_UNI : constant dds_stream_typecode_primary := 589_824;
   DDS_OP_TYPE_STU : constant dds_stream_typecode_primary := 655_360;

   -- sub-type code:
   --   - encodes element type for DDS_OP_TYPE_{SEQ,ARR},
   --   - discriminant type for DDS_OP_TYPE_UNI

   subtype dds_stream_typecode_subtype is unsigned;
   DDS_OP_SUBTYPE_1BY : constant dds_stream_typecode_subtype := 256;
   DDS_OP_SUBTYPE_2BY : constant dds_stream_typecode_subtype := 512;
   DDS_OP_SUBTYPE_4BY : constant dds_stream_typecode_subtype := 768;
   DDS_OP_SUBTYPE_8BY : constant dds_stream_typecode_subtype := 1_024;
   DDS_OP_SUBTYPE_STR : constant dds_stream_typecode_subtype := 1_280;
   DDS_OP_SUBTYPE_BST : constant dds_stream_typecode_subtype := 1_536;
   DDS_OP_SUBTYPE_SEQ : constant dds_stream_typecode_subtype := 1_792;
   DDS_OP_SUBTYPE_ARR : constant dds_stream_typecode_subtype := 2_048;
   DDS_OP_SUBTYPE_UNI : constant dds_stream_typecode_subtype := 2_304;
   DDS_OP_SUBTYPE_STU : constant dds_stream_typecode_subtype := 2_560;

   -- For a union: (1) the discriminator may be a key field; (2) there may be a default value;
   --   and (3) the discriminator can be an integral type (or enumerated - here treated as equivalent).
   --   What it can't be is a floating-point type. So DEF and FP need never be set at the same time.
   --   There are only a few flag bits, so saving one is not such a bad idea.

   -- Topic descriptor flag values
end CycloneDDS.Low_Level.dds_ddsc_dds_opcodes_h;
